"""Dataset and matrix family generators for randomized matrix algorithms.

All functions here are pure (no global state) and designed for reproducible
experiments when given an explicit random seed.

Real-data loaders (e.g. MovieLens, NN weights) are structured so that the
caller passes explicit file paths or preconstructed tensors; this keeps the
module independent of external download logic.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Tuple

import numpy as np
from numpy.typing import NDArray

try:
    import torch
    from torch import Tensor as TorchTensor
except Exception:  # pragma: no cover - torch is optional at import time
    torch = None
    TorchTensor = object  # type: ignore[misc,assignment]


FloatArray = NDArray[np.floating]


@dataclass
class GaussianMatrixSpec:
    """Specification for a dense Gaussian matrix.

    Attributes
    ----------
    m : int
        Number of rows.
    n : int
        Number of columns.
    mean : float
        Mean of the normal distribution.
    std : float
        Standard deviation of the normal distribution.
    seed : int | None
        Random seed; if ``None``, NumPy's global RNG is used.
    """

    m: int
    n: int
    mean: float = 0.0
    std: float = 1.0
    seed: int | None = None


def gaussian_matrix(spec: GaussianMatrixSpec) -> FloatArray:
    """Generate a dense Gaussian matrix.

    Parameters
    ----------
    spec:
        Configuration for the matrix dimensions and distribution.

    Returns
    -------
    ndarray
        Array of shape ``(m, n)`` with i.i.d. ``N(mean, std^2)`` entries.
    """

    rng = np.random.default_rng(spec.seed)
    return rng.normal(loc=spec.mean, scale=spec.std, size=(spec.m, spec.n)).astype(
        np.float64
    )


@dataclass
class LowRankMatrixSpec:
    """Specification for a synthetic approximately low-rank matrix.

    A matrix ``A`` is generated as ``A = U_r Σ_r V_r^T + noise``.
    """

    m: int
    n: int
    r: int
    decay_exponent: float = 1.0
    noise_std: float = 0.0
    seed: int | None = None


def low_rank_matrix(spec: LowRankMatrixSpec) -> FloatArray:
    """Generate a synthetic approximately low-rank matrix.

    Parameters
    ----------
    spec:
        Configuration describing dimensions, target rank, and noise.

    Returns
    -------
    ndarray
        Matrix of shape ``(m, n)`` with effective rank roughly ``r``.
    """

    if spec.r <= 0:
        raise ValueError("rank r must be positive")
    if spec.r > min(spec.m, spec.n):
        raise ValueError("rank r cannot exceed min(m, n)")

    rng = np.random.default_rng(spec.seed)
    u_raw = rng.normal(size=(spec.m, spec.r))
    v_raw = rng.normal(size=(spec.n, spec.r))
    # Orthonormalize columns via QR.
    u_q, _ = np.linalg.qr(u_raw)
    v_q, _ = np.linalg.qr(v_raw)

    # Singular values with power-law decay.
    idx = np.arange(spec.r, dtype=np.float64)
    singular_vals = 1.0 / np.power(1.0 + idx, spec.decay_exponent)
    sigma = np.diag(singular_vals)

    core = u_q[:, : spec.r] @ sigma @ v_q[:, : spec.r].T

    if spec.noise_std > 0.0:
        noise = rng.normal(scale=spec.noise_std, size=(spec.m, spec.n))
        core = core + noise

    return core.astype(np.float64)


@dataclass
class SparseMatrixSpec:
    """Specification for a synthetic sparse matrix.

    The matrix is generated by sampling a dense base (optionally low-rank)
    and then independently zeroing entries with probability ``1 - density``.
    """

    m: int
    n: int
    density: float
    low_rank_r: int | None = None
    seed: int | None = None


def sparse_matrix(spec: SparseMatrixSpec) -> FloatArray:
    """Generate a synthetic sparse (potentially low-rank) matrix.

    Parameters
    ----------
    spec:
        Configuration describing dimensions, density, and optional low-rank
        structure.

    Returns
    -------
    ndarray
        Dense array with many zeros; caller may convert to a sparse format
        if desired.
    """

    if not (0.0 < spec.density <= 1.0):
        raise ValueError("density must be in (0, 1]")

    rng = np.random.default_rng(spec.seed)

    if spec.low_rank_r is not None:
        base = low_rank_matrix(
            LowRankMatrixSpec(
                m=spec.m,
                n=spec.n,
                r=spec.low_rank_r,
                decay_exponent=1.5,
                noise_std=0.0,
                seed=spec.seed,
            )
        )
    else:
        base = gaussian_matrix(GaussianMatrixSpec(m=spec.m, n=spec.n, seed=spec.seed))

    mask = rng.random(size=(spec.m, spec.n)) < spec.density
    result = base * mask
    return result.astype(np.float64)


def nn_like_synthetic(
    m: int,
    n: int,
    r: int | None = None,
    decay_exponent: float = 2.5,
    noise_std: float = 0.0,
    seed: int | None = None,
) -> FloatArray:
    """Generate a synthetic "neural-network-like" weight matrix.

    Construct a low-rank matrix with heavy-tailed singular values. Defaults
    bias toward stronger decay and smaller intrinsic rank so structured
    behavior is visible in experiments.
    """

    if r is None:
        r = max(8, min(m, n) // 16)
    spec = LowRankMatrixSpec(
        m=m,
        n=n,
        r=r,
        decay_exponent=decay_exponent,
        noise_std=noise_std,
        seed=seed,
    )
    return low_rank_matrix(spec)


def sparse_low_rank_matrix(
    m: int,
    n: int,
    r: int,
    density: float = 0.05,
    decay_exponent: float = 1.5,
    seed: int | None = None,
) -> FloatArray:
    """Generate a rank-``r`` matrix with sparse factors (true rank preserved).

    Constructs sparse factors ``U`` and ``V`` with given density and forms
    ``A = U diag(s) V^T`` so that the resulting matrix is low-rank but
    entry-sparse.
    """

    if not (0.0 < density <= 1.0):
        raise ValueError("density must be in (0, 1]")
    if r <= 0 or r > min(m, n):
        raise ValueError("r must be in [1, min(m, n)]")

    rng = np.random.default_rng(seed)

    def _sparse_factor(rows: int) -> FloatArray:
        mat = rng.normal(size=(rows, r))
        mask = rng.random(size=(rows, r)) < density
        mat = mat * mask
        for j in range(r):
            if not np.any(mask[:, j]):
                mat[rng.integers(0, rows), j] = rng.normal()
        q, _ = np.linalg.qr(mat)
        return q[:, :r]

    u_sparse = _sparse_factor(m)
    v_sparse = _sparse_factor(n)

    idx = np.arange(r, dtype=np.float64)
    singulars = 1.0 / np.power(1.0 + idx, decay_exponent)
    sigma = np.diag(singulars)

    return (u_sparse @ sigma @ v_sparse.T).astype(np.float64)


def load_movielens_user_item_matrix(ratings_path: Path, min_ratings: int = 1) -> FloatArray:
    """Load a user–item rating matrix from a MovieLens-style ratings file.

    This function assumes a simple CSV with at least three columns:
    ``user_id, item_id, rating`` (additional columns are ignored).

    Parameters
    ----------
    ratings_path:
        Path to a CSV file containing ratings.
    min_ratings:
        Optional minimum number of ratings required for a user and item to be
        kept; entities with fewer ratings are filtered out.

    Returns
    -------
    ndarray
        Dense user–item matrix ``M ∈ R^{n_users × n_items}`` with zeros for
        missing entries.
    """

    import csv  # local import to keep module import light

    if not ratings_path.is_file():
        raise FileNotFoundError(f"ratings file not found: {ratings_path}")

    user_counts: dict[str, int] = {}
    item_counts: dict[str, int] = {}

    with ratings_path.open("r", newline="") as f:
        reader = csv.reader(f)
        header = next(reader, None)
        for row in reader:
            if len(row) < 3:
                continue
            u, i, _ = row[0], row[1], row[2]
            user_counts[u] = user_counts.get(u, 0) + 1
            item_counts[i] = item_counts.get(i, 0) + 1

    eligible_users = {u for u, c in user_counts.items() if c >= min_ratings}
    eligible_items = {i for i, c in item_counts.items() if c >= min_ratings}

    user_index: dict[str, int] = {u: idx for idx, u in enumerate(sorted(eligible_users))}
    item_index: dict[str, int] = {i: idx for idx, i in enumerate(sorted(eligible_items))}

    m = len(user_index)
    n = len(item_index)
    if m == 0 or n == 0:
        raise ValueError("no users/items satisfy min_ratings filter")

    mat = np.zeros((m, n), dtype=np.float64)

    with ratings_path.open("r", newline="") as f:
        reader = csv.reader(f)
        header = next(reader, None)
        for row in reader:
            if len(row) < 3:
                continue
            u, i, r_str = row[0], row[1], row[2]
            if u not in user_index or i not in item_index:
                continue
            try:
                r = float(r_str)
            except ValueError:
                continue
            mat[user_index[u], item_index[i]] = r

    return mat


def extract_nn_weight_matrix(module: TorchTensor | None) -> FloatArray:
    """Convert a PyTorch weight tensor to a NumPy array.

    This is a small helper to bridge between PyTorch models and NumPy-based
    linear algebra. It assumes the caller passes a leaf tensor (e.g.,
    ``model.linear.weight``).

    Parameters
    ----------
    module:
        PyTorch weight tensor. If ``None`` is given or PyTorch is not
        available, a ``RuntimeError`` is raised.

    Returns
    -------
    ndarray
        Copy of the tensor data as a ``float64`` NumPy array.
    """

    if torch is None or module is None:
        raise RuntimeError("PyTorch is not available or weight tensor is None")

    if not isinstance(module, torch.Tensor):  # type: ignore[unreachable]
        raise TypeError("module must be a torch.Tensor")

    return module.detach().cpu().numpy().astype(np.float64)
